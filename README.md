# C++ OOP: Advanced Tasks Solution

Пылаев Степан 4341 ФКТИ
Этот репозиторий содержит решения трех задач по углубленному C++: генерация чисел, маскирование данных и управление памятью.

## 1. SimpleRNG (Генератор псевдослучайных чисел)
Класс реализует генерацию чисел по формуле линейного конгруэнтного метода:
`X[N+1] = (a * X[N] + c) % m`.

**Детали реализации:**
*   **Типы данных:** Коэффициенты `a`, `c`, `m` хранятся в `double`. Для вычисления остатка от деления вещественных чисел используется функция `std::fmod` из библиотеки `<cmath>`.
*   **Итератор:** Реализован вложенный класс `Iterator`, удовлетворяющий требованиям `std::input_iterator_tag`. Это позволяет использовать генератор в стандартных циклах и алгоритмах STL.
*   **Остановка (Sentinel):** Метод `end(eps)` возвращает специальный итератор. Сравнение с ним возвращает `true`, если текущее значение генератора приблизилось к начальному (`X[0]`) на расстояние меньше `eps`. Это позволяет остановить перебор при зацикливании последовательности.

## 2. Mask (Операции с маской)
Шаблонный класс `Mask<Size>` позволяет фильтровать и изменять данные в контейнерах на основе битового паттерна (0 и 1).

**Детали реализации:**
*   **Валидация:** Используется `static_assert` и Variadic Templates для проверки количества аргументов маски на этапе компиляции. В рантайме проверяется, что значения равны строго 0 или 1.
*   **Slice (Срез):** Метод изменяет контейнер "на месте" (in-place). Используется алгоритм двух итераторов (read/write): элементы, соответствующие `1`, перемещаются в начало, а хвост контейнера обрезается через `resize`.
*   **Transform:** Создает новый контейнер, применяя пользовательскую функцию только к элементам, соответствующим `1` в маске. Маска применяется циклично (по модулю размера маски).

## 3. MemReserver (Выделятор памяти)
Класс реализует пул статической памяти для объектов типа `T` без использования динамической аллокации (кучи).

**Детали реализации:**
*   **Хранение:** Память выделена как массив `std::byte` с выравниванием `alignas(T)`. Это критически важно для предотвращения ошибок доступа к памяти на уровне процессора.
*   **Placement New:** Метод `create` использует конструкцию `new (addr) T(...)` для создания объекта в уже выделенном буфере.
*   **Perfect Forwarding:** Аргументы передаются через `std::forward`, что позволяет избежать лишних копирований при создании объектов.
*   **Ручное удаление:** Метод `delete_item` вручную вызывает деструктор объекта `ptr->~T()` и помечает слот как свободный.
*   **Адресная арифметика:** Метод `position` вычисляет индекс объекта, сравнивая его адрес с началом буфера. Реализованы проверки на выход за границы и корректность выравнивания указателя.
