# cpp-advanced-tasks
4341_Пылаев_Степан ФКТИ
# Решение заданий по C++ (ООП)

В данном репозитории представлены реализации трех задач: генератор псевдослучайных чисел, манипуляции с контейнерами через битовую маску и собственный менеджер памяти.

## Задача 1: SimpleRNG (Генератор псевдослучайных чисел)
Класс реализует линейный конгруэнтный метод генерации чисел по формуле:
`X[N+1] = ( a * X[N] + c ) % m`.

**Особенности реализации:**
1. **Итератор:** Для класса реализован `InputIterator`. Это позволяет использовать генератор в стандартных алгоритмах (например, `std::copy`) и range-based циклах.
2. **Типы данных:** Поскольку коэффициенты `a` и `c` вещественные, для операции взятия остатка используется `std::fmod`, а не `%`.
3. **Метод `end(eps)`:** Возвращает специальный итератор-"стражник". Сравнение текущего итератора с `end` (`!=`) проверяет, не приблизилось ли текущее значение генератора к начальному (`x0`) с точностью `eps`. Это позволяет остановить генерацию при зацикливании последовательности.

## Задача 2: Mask (Операции с индексной маской)
Шаблонный класс `Mask<N>` позволяет фильтровать и преобразовывать элементы в любых STL-совместимых контейнерах.

**Особенности реализации:**
1. **Валидация:** Конструктор использует Variadic Templates (`Args...`) и `static_assert` для проверки соответствия количества аргументов размеру маски `N` на этапе компиляции.
2. **`slice`:** Работает "на месте" (in-place). Использует алгоритм двух указателей (read/write index), чтобы сдвинуть нужные элементы в начало контейнера, после чего обрезает хвост через `resize`. Маска применяется циклично через оператор модуля `%`.
3. **`transform` / `slice_and_transform`:** Создают и возвращают новые контейнеры, применяя переданную функцию (лямбду или функтор) только к элементам, соответствующим `1` в маске.

## Задача 3: MemReserver (Выделятор памяти)
Класс управляет статической памятью для объектов типа `T` без использования `std::vector` или других динамических контейнеров.

**Особенности реализации:**
1. **Хранение:** Память выделяется как массив байт `std::byte` с выравниванием `alignas(T)`, чтобы удовлетворить требованиям процессора к доступу к данным.
2. **Placement New:** Метод `create` использует placement new (`new (addr) T(...)`) для конструирования объекта в уже выделенном сыром буфере памяти. Аргументы передаются через `std::forward` для идеальной пересылки.
3. **Ручное управление жизнью:** Метод `destroy` (аналог `delete` из задания) явно вызывает деструктор `obj->~T()`.
4. **Поиск позиции:** Метод `position` использует адресную арифметику: вычисляет смещение указателя объекта относительно начала буфера и делит на размер типа `T`. Также проверяется валидность адреса (принадлежит ли он пулу памяти).

### Запуск
Для компиляции требуется поддержка C++17 (из-за `std::byte`, `if constexpr` и `std::invoke` особенностей).
Пример сборки:
```bash
g++ main.cpp -std=c++17 -o solution
./solution
