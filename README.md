# C++ Advanced OOP Solutions

Данный репозиторий содержит реализацию трех заданий в рамках курса углубленного изучения C++. Код написан на стандарте C++17.

## 1. Генератор псевдослучайных чисел (SimpleRNG)

Класс `SimpleRNG` реализует линейный конгруэнтный метод генерации чисел с плавающей точкой.
Формула генерации: $X_{n+1} = (a \cdot X_n + c) \pmod m$.

### Особенности реализации:
*   **Арифметика:** Поскольку работа ведется с типом `double`, для вычисления остатка от деления используется функция стандартной библиотеки `std::fmod`.
*   **Input Iterator:** Для класса реализован полноценный итератор, совместимый с STL. Это позволяет использовать генератор в стандартных алгоритмах (например, `std::copy`) и range-based циклах. Итератор соответствует категории `std::input_iterator_tag`.
*   **Остановка генерации:** Метод `end(epsilon)` возвращает специальный итератор-"стражник". Оператор сравнения `==` реализован нетривиально: он проверяет, приблизилось ли текущее значение генератора к начальному (`start_val`) на расстояние меньше `epsilon`. Это позволяет автоматически прерывать цикл при зацикливании последовательности (возврате в начало).

## 2. Операции с индексной маской (Mask)

Шаблонный класс `Mask<Sz>` предназначен для фильтрации и трансформации элементов в контейнерах на основе битового паттерна. Размер маски задается параметром шаблона `Sz`.

### Особенности реализации:
*   **Конструктор с валидацией:** Используются вариативные шаблоны (Variadic Templates) для инициализации маски. Проверка соответствия количества аргументов размеру маски `Sz` выполняется на этапе компиляции через `static_assert`. Также в конструкторе проверяется, что значения равны только 0 или 1.
*   **Алгоритм Slice (in-place):** Метод `slice` модифицирует переданный контейнер без создания его копии. Реализован алгоритм **Read/Write pointers**:
    1. Итератор чтения проходит по всем элементам.
    2. Если бит маски равен 1, элемент перемещается (`std::move`) в позицию итератора записи.
    3. После прохода лишние элементы в конце контейнера удаляются методом `resize`.
    Маска применяется циклично с использованием оператора модуля `%`.
*   **Гибкая трансформация:** Методы `transform` и `slice_and_transform` позволяют применять произвольную функцию к элементам, соответствующим единице в маске, возвращая новый контейнер.

## 3. Менеджер статической памяти (MemReserver)

Класс `MemReserver<T, Cap>` реализует пул объектов фиксированного размера без использования динамической памяти (кучи) и стандартных контейнеров вроде `std::vector`.

### Особенности реализации:
*   **Выравнивание памяти:** Буфер для хранения объектов объявлен как массив `std::byte` с спецификатором `alignas(T)`. Это гарантирует корректное выравнивание данных в памяти, что критично для сложных типов данных и производительности процессора.
*   **Placement New:** Создание объектов (метод `create`) происходит через *placement new*. Объект конструируется непосредственно в заранее выделенном буфере ("сырой" памяти).
*   **Perfect Forwarding:** Аргументы метода `create` передаются в конструктор объекта через `std::forward`, что позволяет избежать лишних копирований.
*   **Управление жизненным циклом:**
    *   Метод `del` (аналог delete) вручную вызывает деструктор объекта `~T()`.
    *   Деструктор самого `MemReserver` корректно очищает все оставшиеся активные объекты.
*   **Адресная арифметика:** Метод `position` определяет индекс объекта путем вычисления смещения его адреса относительно начала буфера. Включены проверки на принадлежность указателя диапазону памяти пула и корректность выравнивания (попадание в начало слота).
*   **Обработка ошибок:** Реализована иерархия собственных исключений (`StorageOverflow`, `BadSlotAccess`, `UnknownObject`) для безопасной обработки некорректных ситуаций.
